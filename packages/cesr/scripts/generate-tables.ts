const encoder = new TextEncoder();

const LEGACY_V1_COUNTER_NAME_ALIASES: Record<string, string> = {
  "-J": "SadPathSig",
  "-K": "SadPathSigGroup",
};

const LEGACY_V1_COUNTER_SIZE_ALIASES: Record<
  string,
  { hs: number; ss: number; fs: number }
> = {
  "-J": { hs: 2, ss: 2, fs: 4 },
  "-K": { hs: 2, ss: 2, fs: 4 },
};

const COMPAT_V2_COUNTER_SIZE_ALIASES: Record<
  string,
  { hs: number; ss: number; fs: number }
> = {
  "-J": { hs: 2, ss: 2, fs: 4 },
};

function resolveKeripyPath(): string {
  const env = Deno.env.get("KERIPY_PATH");
  if (env) return env;
  return "/Users/kbull/code/keri/kentbull/keripy";
}

async function readFile(path: string): Promise<string> {
  return await Deno.readTextFile(path);
}

function parseMatterCodex(text: string): Record<string, string> {
  const start = text.indexOf("class MatterCodex");
  if (start < 0) throw new Error("MatterCodex class not found");
  const chunk = text.slice(
    start,
    text.indexOf("MtrDex = MatterCodex()", start),
  );
  const regex = /^\s+([A-Za-z0-9_]+):\s+str\s*=\s*'([^']+)'/gm;
  const out: Record<string, string> = {};
  for (const match of chunk.matchAll(regex)) {
    out[match[2]] = match[1];
  }
  return out;
}

function parseMatterSizes(
  text: string,
): Record<
  string,
  { hs: number; ss: number; xs: number; fs: number | null; ls: number }
> {
  const start = text.indexOf("Sizes = {");
  if (start < 0) throw new Error("Matter Sizes table not found");
  const end = text.indexOf("\n\n    Codes = asdict(MtrDex)", start);
  const chunk = text.slice(start, end);
  const regex =
    /'([^']+)':\s+Sizage\(hs=(\d+),\s*ss=(\d+),\s*xs=(\d+),\s*fs=(None|\d+),\s*ls=(\d+)\)/g;
  const out: Record<
    string,
    { hs: number; ss: number; xs: number; fs: number | null; ls: number }
  > = {};
  for (const match of chunk.matchAll(regex)) {
    out[match[1]] = {
      hs: Number.parseInt(match[2], 10),
      ss: Number.parseInt(match[3], 10),
      xs: Number.parseInt(match[4], 10),
      fs: match[5] === "None" ? null : Number.parseInt(match[5], 10),
      ls: Number.parseInt(match[6], 10),
    };
  }
  return out;
}

function parseCounterCodexes(
  text: string,
): { v1: Record<string, string>; v2: Record<string, string> } {
  const classV1 = text.slice(
    text.indexOf("class CounterCodex_1_0"),
    text.indexOf("CtrDex_1_0 = CounterCodex_1_0()"),
  );
  const classV2 = text.slice(
    text.indexOf("class CounterCodex_2_0"),
    text.indexOf("CtrDex_2_0 = CounterCodex_2_0()"),
  );

  const regex = /^\s+([A-Za-z0-9_]+):\s+str\s*=\s*'([^']+)'/gm;
  const v1: Record<string, string> = {};
  const v2: Record<string, string> = {};

  for (const match of classV1.matchAll(regex)) v1[match[2]] = match[1];
  for (const match of classV2.matchAll(regex)) v2[match[2]] = match[1];
  return { v1, v2 };
}

function parseCounterSizes(
  text: string,
): {
  v1: Record<string, { hs: number; ss: number; fs: number }>;
  v2: Record<string, { hs: number; ss: number; fs: number }>;
} {
  const start = text.indexOf("Sizes = \\");
  if (start < 0) throw new Error("Counter Sizes block not found");
  const end = text.indexOf("\n\n\n    def __init__", start);
  const chunk = text.slice(start, end);

  const v1Block = chunk.slice(
    chunk.indexOf("Vrsn_1_0.minor:"),
    chunk.indexOf("Vrsn_2_0.major:"),
  );
  const v2Block = chunk.slice(chunk.indexOf("Vrsn_2_0.minor:"));

  const regex = /'([^']+)':\s+Cizage\(hs=(\d+),\s*ss=(\d+),\s*fs=(\d+)\)/g;

  const parseBlock = (
    block: string,
  ): Record<string, { hs: number; ss: number; fs: number }> => {
    const out: Record<string, { hs: number; ss: number; fs: number }> = {};
    for (const match of block.matchAll(regex)) {
      out[match[1]] = {
        hs: Number.parseInt(match[2], 10),
        ss: Number.parseInt(match[3], 10),
        fs: Number.parseInt(match[4], 10),
      };
    }
    return out;
  };

  return { v1: parseBlock(v1Block), v2: parseBlock(v2Block) };
}

function emitMatterTables(
  sizes: Record<
    string,
    { hs: number; ss: number; xs: number; fs: number | null; ls: number }
  >,
  names: Record<string, string>,
): string {
  const entries = Object.entries(sizes).sort(([a], [b]) => a.localeCompare(b));
  const nameEntries = Object.entries(names).sort(([a], [b]) =>
    a.localeCompare(b)
  );
  return `// Generated by packages/cesr/scripts/generate-tables.ts\nimport type { Sizage } from './table-types.ts';\n\nexport const MATTER_SIZES = new Map<string, Sizage>([\n${
    entries
      .map(([code, s]) =>
        `  ['${code}', { hs: ${s.hs}, ss: ${s.ss}, xs: ${s.xs}, fs: ${
          s.fs === null ? "null" : s.fs
        }, ls: ${s.ls} }],`
      )
      .join("\n")
  }\n]);\n\nexport const MATTER_CODE_NAMES = {\n${
    nameEntries.map(([code, name]) => `  '${code}': '${name}',`).join("\n")
  }\n} as const;\n\nexport const MATTER_HARDS = new Map<string, number>([\n  ...'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('').map((c) => [c, 1] as [string, number]),\n  ...'abcdefghijklmnopqrstuvwxyz'.split('').map((c) => [c, 1] as [string, number]),\n  ['0', 2], ['1', 4], ['2', 4], ['3', 4], ['4', 2], ['5', 2], ['6', 2], ['7', 4], ['8', 4], ['9', 4],\n]);\n`;
}

function emitCounterTables(
  v1: Record<string, { hs: number; ss: number; fs: number }>,
  v2: Record<string, { hs: number; ss: number; fs: number }>,
  namesV1: Record<string, string>,
  namesV2: Record<string, string>,
): string {
  const entriesV1 = Object.entries(v1).sort(([a], [b]) => a.localeCompare(b));
  const entriesV2 = Object.entries(v2).sort(([a], [b]) => a.localeCompare(b));
  const nameEntriesV1 = Object.entries(namesV1).sort(([a], [b]) =>
    a.localeCompare(b)
  );
  const nameEntriesV2 = Object.entries(namesV2).sort(([a], [b]) =>
    a.localeCompare(b)
  );

  return `// Generated by packages/cesr/scripts/generate-tables.ts\nimport type { Cizage } from './table-types.ts';\n\nexport const COUNTER_SIZES_V1 = new Map<string, Cizage>([\n${
    entriesV1
      .map(([code, s]) =>
        `  ['${code}', { hs: ${s.hs}, ss: ${s.ss}, fs: ${s.fs} }],`
      )
      .join("\n")
  }\n]);\n\nexport const COUNTER_SIZES_V2 = new Map<string, Cizage>([\n${
    entriesV2
      .map(([code, s]) =>
        `  ['${code}', { hs: ${s.hs}, ss: ${s.ss}, fs: ${s.fs} }],`
      )
      .join("\n")
  }\n]);\n\nexport const COUNTER_HARDS = new Map<string, number>([\n  ...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('').map((c) => [\`-\${c}\`, 2] as [string, number]),\n  ['--', 3],\n  ['-_', 5],\n]);\n\nexport const COUNTER_CODE_NAMES_V1 = {\n${
    nameEntriesV1.map(([code, name]) => `  '${code}': '${name}',`).join("\n")
  }\n} as const;\n\nexport const COUNTER_CODE_NAMES_V2 = {\n${
    nameEntriesV2.map(([code, name]) => `  '${code}': '${name}',`).join("\n")
  }\n} as const;\n`;
}

function applyLegacyV1CounterAliases(
  sizes: Record<string, { hs: number; ss: number; fs: number }>,
  names: Record<string, string>,
): {
  sizes: Record<string, { hs: number; ss: number; fs: number }>;
  names: Record<string, string>;
} {
  const outSizes = { ...sizes };
  const outNames = { ...names };

  for (const [code, size] of Object.entries(LEGACY_V1_COUNTER_SIZE_ALIASES)) {
    if (!outSizes[code]) {
      outSizes[code] = size;
    }
  }
  for (const [code, name] of Object.entries(LEGACY_V1_COUNTER_NAME_ALIASES)) {
    if (!outNames[code]) {
      outNames[code] = name;
    }
  }

  return { sizes: outSizes, names: outNames };
}

function applyCompatV2CounterSizeAliases(
  sizes: Record<string, { hs: number; ss: number; fs: number }>,
  names: Record<string, string>,
): Record<string, { hs: number; ss: number; fs: number }> {
  const outSizes = { ...sizes };
  for (const [code, size] of Object.entries(COMPAT_V2_COUNTER_SIZE_ALIASES)) {
    if (names[code] && !outSizes[code]) {
      outSizes[code] = size;
    }
  }
  return outSizes;
}

async function main(): Promise<void> {
  const keripyPath = resolveKeripyPath();
  const coring = await readFile(`${keripyPath}/src/keri/core/coring.py`);
  const counting = await readFile(`${keripyPath}/src/keri/core/counting.py`);

  const matterSizes = parseMatterSizes(coring);
  const matterNames = parseMatterCodex(coring);
  const counterNames = parseCounterCodexes(counting);
  const counterSizes = parseCounterSizes(counting);
  const compatV1 = applyLegacyV1CounterAliases(counterSizes.v1, counterNames.v1);
  const compatV2Sizes = applyCompatV2CounterSizeAliases(
    counterSizes.v2,
    counterNames.v2,
  );

  await Deno.writeTextFile(
    "packages/cesr/src/tables/matter.tables.generated.ts",
    emitMatterTables(matterSizes, matterNames),
  );

  await Deno.writeTextFile(
    "packages/cesr/src/tables/counter.tables.generated.ts",
    emitCounterTables(
      compatV1.sizes,
      compatV2Sizes,
      compatV1.names,
      counterNames.v2,
    ),
  );

  await Deno.stdout.write(
    encoder.encode("Generated CESR tables from KERIpy source.\n"),
  );
}

if (import.meta.main) {
  await main();
}
