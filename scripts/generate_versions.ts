/**
 * Generate runtime version modules from package manifest versions.
 *
 * Usage:
 *   deno run -A scripts/generate_versions.ts
 *   deno run -A scripts/generate_versions.ts --check
 *   deno run -A scripts/generate_versions.ts --only keri
 *   deno run -A scripts/generate_versions.ts --only cesr
 */

interface GenerateTarget {
  name: "keri" | "cesr";
  packagePath: URL;
  outputPath: URL;
  envOverrideKey: string;
}

interface PackageManifest {
  version?: string;
}

const TARGETS: GenerateTarget[] = [
  {
    name: "keri",
    packagePath: new URL("../package.json", import.meta.url),
    outputPath: new URL("../src/app/version.ts", import.meta.url),
    envOverrideKey: "KERI_TS_BUILD_METADATA",
  },
  {
    name: "cesr",
    packagePath: new URL("../packages/cesr/package.json", import.meta.url),
    outputPath: new URL("../packages/cesr/src/version.ts", import.meta.url),
    envOverrideKey: "CESR_TS_BUILD_METADATA",
  },
];

const SEMVER_REGEX =
  /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-[0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*)?$/;
const BUILD_METADATA_REGEX = /^[0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*$/;

function parseArgs(args: string[]) {
  let check = false;
  let only: "all" | "keri" | "cesr" = "all";

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg === "--check") {
      check = true;
      continue;
    }

    if (arg === "--only") {
      const next = args[i + 1];
      if (next !== "keri" && next !== "cesr") {
        throw new Error("--only must be 'keri' or 'cesr'");
      }
      only = next;
      i++;
      continue;
    }

    throw new Error(`Unknown argument: ${arg}`);
  }

  return { check, only };
}

function normalizeBuildMetadata(input: string): string {
  const cleaned = input.trim().replace(/[^0-9A-Za-z.-]+/g, "-").replace(
    /\.{2,}/g,
    ".",
  ).replace(/^-+|-+$/g, "");

  if (!cleaned) {
    return "";
  }

  if (!BUILD_METADATA_REGEX.test(cleaned)) {
    throw new Error(`Invalid build metadata: ${input}`);
  }

  return cleaned;
}

function computeDefaultBuildMetadata(): string {
  const run = Deno.env.get("GITHUB_RUN_NUMBER") ??
    Deno.env.get("GITHUB_RUN_ID");
  const sha = Deno.env.get("GITHUB_SHA")?.slice(0, 8);

  if (run && sha) {
    return `build.${run}.${sha}`;
  }

  if (run) {
    return `build.${run}`;
  }

  if (sha) {
    return `build.${sha}`;
  }

  return "";
}

function getBuildMetadata(target: GenerateTarget): string {
  const explicit = Deno.env.get(target.envOverrideKey) ??
    Deno.env.get("BUILD_METADATA");
  if (explicit) {
    return normalizeBuildMetadata(explicit);
  }

  return computeDefaultBuildMetadata();
}

async function readPackageVersion(path: URL): Promise<string> {
  const raw = await Deno.readTextFile(path);
  const pkg = JSON.parse(raw) as PackageManifest;
  const version = pkg.version?.trim();

  if (!version) {
    throw new Error(`Missing version in ${path}`);
  }

  if (!SEMVER_REGEX.test(version)) {
    throw new Error(
      `Invalid semver in ${path}: ${version}. Expected x.y.z or x.y.z-prerelease.`,
    );
  }

  return version;
}

function renderVersionModule(version: string, buildMetadata: string): string {
  const escapedVersion = JSON.stringify(version);
  const escapedMetadata = JSON.stringify(buildMetadata);

  return `/**
 * Generated by scripts/generate_versions.ts.
 * Do not edit by hand.
 */
export const PACKAGE_VERSION = ${escapedVersion};
export const BUILD_METADATA = ${escapedMetadata};
export const DISPLAY_VERSION = BUILD_METADATA
  ? \`\${PACKAGE_VERSION}+\${BUILD_METADATA}\`
  : PACKAGE_VERSION;
`;
}

async function ensureVersionModule(
  target: GenerateTarget,
  check: boolean,
): Promise<void> {
  const packageVersion = await readPackageVersion(target.packagePath);
  const buildMetadata = getBuildMetadata(target);
  const expected = renderVersionModule(packageVersion, buildMetadata);

  let current = "";
  try {
    current = await Deno.readTextFile(target.outputPath);
  } catch (error) {
    if (!(error instanceof Deno.errors.NotFound)) {
      throw error;
    }
  }

  if (current === expected) {
    return;
  }

  if (check) {
    throw new Error(
      `Version module out of date: ${target.outputPath}. Run deno task version:generate.`,
    );
  }

  await Deno.writeTextFile(target.outputPath, expected);
}

async function main() {
  const { check, only } = parseArgs(Deno.args);
  const targets = only === "all"
    ? TARGETS
    : TARGETS.filter((target) => target.name === only);

  for (const target of targets) {
    await ensureVersionModule(target, check);
  }
}

if (import.meta.main) {
  try {
    await main();
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    console.error(`version generation failed: ${message}`);
    Deno.exit(1);
  }
}
